<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Multimodal Dataset Registry</title>
    <style>
      :root {
        --bg-start: #fdf4ff;
        --bg-end: #eef6ff;
        --card: #ffffff;
        --card-accent: #f6f8ff;
        --ink: #1f2a37;
        --ink-muted: #6b7280;
        --border: #e3e8f4;
        --accent: #7c3aed;
        --accent-2: #0ea5e9;
        --accent-soft: rgba(124, 58, 237, 0.08);
        --danger: #db2777;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
        color: var(--ink);
        background: linear-gradient(140deg, var(--bg-start), var(--bg-end));
        padding: clamp(1.5rem, 4vw, 2.75rem);
      }

      main {
        max-width: 1200px;
        margin: 0 auto;
        background: var(--card);
        border-radius: 28px;
        padding: clamp(1.5rem, 4vw, 2.5rem);
        border: 1px solid var(--border);
        box-shadow: 0 25px 60px rgba(100, 116, 139, 0.12);
      }

      .header-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
      }

      h1 {
        margin: 0;
        font-size: clamp(2.1rem, 4vw, 3rem);
      }

      .add-btn {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        color: #fff;
        text-decoration: none;
        padding: 0.75rem 1.5rem;
        border-radius: 999px;
        font-weight: 600;
        box-shadow: 0 10px 20px rgba(124, 58, 237, 0.2);
        transition: transform 0.2s;
      }

      .add-btn:hover {
        transform: translateY(-2px);
        text-decoration: none;
      }

      .card {
        background: var(--card-accent);
        border-radius: 20px;
        border: 1px solid var(--border);
        padding: clamp(1.25rem, 3vw, 1.75rem);
      }

      form {
        display: flex;
        flex-direction: column;
        gap: 1.2rem;
      }

      fieldset {
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 1rem 1.2rem 1.2rem;
        margin: 0;
        background: #fff;
      }

      fieldset legend {
        padding: 0 0.4rem;
        text-transform: uppercase;
        font-weight: 600;
        letter-spacing: 0.08em;
        color: var(--accent);
      }

      .field-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1rem;
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-weight: 600;
        font-size: 0.9rem;
      }

      label span.helper {
        font-size: 0.78rem;
        font-weight: 500;
        color: var(--ink-muted);
      }

      input,
      select,
      textarea {
        border-radius: 12px;
        border: 1px solid #d4dbe8;
        padding: 0.65rem 0.85rem;
        font-family: inherit;
        font-size: 1rem;
        background: #fff;
        color: var(--ink);
      }

      textarea {
        min-height: 80px;
        resize: vertical;
      }

      summary {
        cursor: pointer;
        font-weight: 600;
        color: var(--accent);
        margin-bottom: 0.8rem;
      }

      details.retrieval {
        border: 1px dashed var(--border);
        border-radius: 16px;
        padding: 0.9rem 1rem 0.4rem;
        background: var(--card-accent);
      }

      .actions {
        display: flex;
        justify-content: flex-end;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      button {
        border: none;
        border-radius: 999px;
        padding: 0.65rem 1.4rem;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        color: #fff;
        box-shadow: 0 15px 30px rgba(14, 165, 233, 0.25);
        transition: transform 120ms ease, box-shadow 120ms ease;
      }

      button.secondary {
        background: #fff;
        color: var(--accent);
        border: 1px solid rgba(124, 58, 237, 0.4);
        box-shadow: none;
      }

      button.danger {
        background: var(--danger);
        box-shadow: none;
      }

      button:hover {
        transform: translateY(-1px);
      }

      button.secondary:hover,
      button.danger:hover {
        transform: none;
      }

      .button-link {
        display: inline-block;
        border: none;
        border-radius: 999px;
        padding: 0.65rem 1.4rem;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        background: linear-gradient(135deg, var(--accent), var(--accent-2));
        color: #fff;
        box-shadow: 0 15px 30px rgba(14, 165, 233, 0.25);
        transition: transform 120ms ease, box-shadow 120ms ease;
        text-decoration: none;
      }

      .button-link:hover {
        transform: translateY(-1px);
      }

      .table-section {
        margin-top: 2.2rem;
      }

      .table-filters {
        margin-top: 1rem;
        padding: 0.8rem 1rem;
        border-radius: 16px;
        border: 1px solid var(--border);
        background: var(--card-accent);
      }

      .filters-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.8rem;
        align-items: end;
      }

      .filters-grid label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.85rem;
        font-weight: 600;
      }

      .filters-grid select,
      .filters-grid input {
        border-radius: 999px;
        border: 1px solid #d4dbe8;
        padding: 0.5rem 0.9rem;
        font-size: 0.95rem;
        background: #fff;
      }

      .filters-grid label.search {
        grid-column: span 2;
      }

      .table-wrapper {
        margin-top: 0.9rem;
        border-radius: 24px;
        border: 1px solid var(--border);
        overflow-x: auto;
        background: #fff;
      }

      .dataset-grid {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
      }

      .dataset-card {
        background: #fff;
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 1.5rem;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
      }

      .card-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 1rem;
        flex-wrap: wrap;
        gap: 1rem;
      }

      .card-title {
        font-size: 1.25rem;
        font-weight: 700;
        color: var(--ink);
        margin: 0;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      
      .card-title a {
        font-size: 0.85rem;
        font-weight: 500;
        background: var(--bg-start);
        padding: 0.2rem 0.6rem;
        border-radius: 6px;
        border: 1px solid var(--border);
        text-decoration: none;
        color: var(--accent);
      }

      .card-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-bottom: 1.25rem;
      }
      
      .tag-pill {
        background: var(--card-accent);
        border: 1px solid var(--border);
        padding: 0.25rem 0.75rem;
        border-radius: 99px;
        font-size: 0.85rem;
        color: var(--ink);
        font-weight: 500;
      }
      
      .tag-pill.highlight {
        background: rgba(124, 58, 237, 0.08);
        color: var(--accent);
        border-color: rgba(124, 58, 237, 0.2);
      }

      .card-content {
        display: grid;
        grid-template-columns: 1.8fr 1.2fr;
        gap: 2rem;
        font-size: 0.95rem;
        color: var(--ink);
      }
      
      @media (max-width: 900px) {
        .card-content {
          grid-template-columns: 1fr;
          gap: 1rem;
        }
      }

      .card-description p {
        margin-top: 0;
        line-height: 1.6;
      }
      
      .card-logistics {
        background: var(--card-accent);
        padding: 1.25rem;
        border-radius: 12px;
        font-size: 0.9rem;
        border: 1px solid var(--border);
      }
      
      .logistics-item {
        margin-bottom: 0.8rem;
      }
      
      .logistics-item:last-child {
        margin-bottom: 0;
      }
      
      .logistics-label {
        font-weight: 600;
        display: block;
        margin-bottom: 0.3rem;
        color: var(--ink-muted);
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }

      .card-retrieval {
        margin-top: 1.5rem;
        padding-top: 1.25rem;
        border-top: 1px solid var(--border);
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1.5rem;
      }
      
      .retrieval-item {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
      }
      
      .retrieval-label {
        font-size: 0.75rem;
        text-transform: uppercase;
        color: var(--ink-muted);
        font-weight: 700;
        letter-spacing: 0.05em;
      }
      
      .retrieval-value {
        font-weight: 500;
      }

      .card-actions {
        display: flex;
        gap: 0.5rem;
      }

      .muted {
        color: var(--ink-muted);
        font-size: 0.9rem;
      }

      @media (max-width: 720px) {
        body {
          padding: 1rem;
        }

        table {
          min-width: 900px;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <div class="header-actions">
        <h1>Multimodal Dataset Registry</h1>
        <a href="add-dataset/" class="add-btn">
          <span>+</span> Add New Dataset
        </a>
      </div>

      <section class="table-section">
        <div class="table-filters">
          <div class="filters-grid">
            <label>
              Type filter
              <select id="filter-type" data-placeholder="All types" data-filter-key="type"></select>
            </label>
            <label>
              Domain filter
              <select id="filter-domain" data-placeholder="All domains" data-filter-key="domain"></select>
            </label>
            <label>
              Tag filter
              <select id="filter-tag" data-placeholder="All tags" data-filter-key="tag"></select>
            </label>
            <label class="search">
              Search entries
              <input type="search" id="filter-search" placeholder="Search dataset fields..." />
            </label>
          </div>
        </div>
        <div class="table-wrapper">
          <div id="dataset-grid" class="dataset-grid"><p class="muted" id="loading-msg">Loading registry…</p></div>
        </div>
      </section>
    </main>

    <script src="{{ "js/firebase-config.js" | relURL }}"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore-compat.js"></script>
    <script>
      // Replace with your Firebase project config from Firebase Console → Project settings
      const FIREBASE_CONFIG = window.FIREBASE_CONFIG || {
        apiKey: "YOUR_API_KEY",
        authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
        projectId: "YOUR_PROJECT_ID",
        storageBucket: "YOUR_PROJECT_ID.appspot.com",
        messagingSenderId: "YOUR_SENDER_ID",
        appId: "YOUR_APP_ID",
      };
      const FIRESTORE_DOC = "registry/entries";
      let firestoreDb = null;
      try {
        firebase.initializeApp(FIREBASE_CONFIG);
        firestoreDb = firebase.firestore();
      } catch (e) {
        console.warn("Firebase init failed; using localStorage fallback.", e);
      }

      const gridContainer = document.getElementById("dataset-grid");
      const filterControls = {
        type: document.getElementById("filter-type"),
        domain: document.getElementById("filter-domain"),
        tag: document.getElementById("filter-tag"),
        search: document.getElementById("filter-search"),
      };
      const filters = { type: "", domain: "", tag: "", search: "" };
      const MODALITY_OPTIONS = ["Text", "Image", "Video", "Audio", "Table", "Thermal", "IMU", "Other"];

      const normalizeModalities = (value) => {
        const rawList = Array.isArray(value)
          ? value
          : typeof value === "string"
          ? value.split(/[+,\/]+/)
          : [];

        const normalized = rawList
          .map((token) => token.trim())
          .filter(Boolean)
          .map((token) => {
            const exactMatch = MODALITY_OPTIONS.find(
              (option) => option.toLowerCase() === token.toLowerCase()
            );
            if (exactMatch) return exactMatch;
            if (/table/i.test(token)) return "Table";
            if (/thermal/i.test(token)) return "Thermal";
            if (/imu/i.test(token)) return "IMU";
            if (/video/i.test(token)) return "Video";
            if (/audio|speech/i.test(token)) return "Audio";
            if (/image|vision|visual/i.test(token)) return "Image";
            if (/text|language/i.test(token)) return "Text";
            return "Other";
          });

        const unique = [...new Set(normalized)];
        return unique.sort(
          (a, b) => MODALITY_OPTIONS.indexOf(a) - MODALITY_OPTIONS.indexOf(b)
        );
      };

      const formatModalities = (modalities = []) =>
        modalities.length ? modalities.join(" + ") : "—";

      const getSelectValues = (select) =>
        Array.from(select.selectedOptions || []).map((option) => option.value);

      const setSelectValues = (select, values = []) => {
        const normalized = normalizeModalities(values);
        Array.from(select.options).forEach((option) => {
          option.selected = normalized.includes(option.value);
        });
      };

      const seedEntries = [
        {
          id: "seed-1",
          type: "Evaluation Set",
          task: "TextbookQA",
          modalities: ["Text", "Image"],
          domain: "Education",
          dataPoints: 15154,
          taskCategory: "Multimodal Machine Comprehension",
          description:
            "Multiple-choice questions sourced from middle school textbooks that demand joint text + illustration reasoning.",
          specialty:
            "Strong focus on grade-school science topics; visuals frequently hold the missing clue.",
          paperLink: "",
          dataLink: "https://prior.allenai.org/projects/tqa",
          loadData:
            "Complete train/val/test zip (1.6 GB): https://s3.amazonaws.com/ai2-vision-textbook-dataset/dataset_releases/tqa/tqa_train_val_test.zip",
          dataSize: 1.6,
          queryMod: "T+I",
          targetMod: "T",
          numQuery: 15154,
          numCandidates: "",
          customTags: [],
        },
        {
          id: "seed-2",
          type: "Evaluation Set",
          task: "DocVQA",
          modalities: ["Text", "Image"],
          domain: "Documents",
          dataPoints: 50000,
          taskCategory: "Visual QA",
          description:
            "Document understanding benchmark with OCR-heavy pages spanning invoices, forms, and archival scans.",
          specialty:
            "Mix of noisy scans and contemporary layouts; leaderboard hosted through ICDAR/RRC.",
          paperLink: "",
          dataLink: "https://www.docvqa.org/datasets",
          loadData: "RRC portal download: https://www.docvqa.org/datasets",
          dataSize: "",
          queryMod: "T+I",
          targetMod: "T",
          numQuery: 50000,
          numCandidates: 12767,
          customTags: [],
        },
        {
          id: "seed-3",
          type: "Evaluation Set",
          task: "SlideVQA",
          modalities: ["Text", "Image"],
          domain: "Presentation Slides",
          dataPoints: 14484,
          taskCategory: "Visual QA",
          description:
            "Question answering benchmark built on corporate + academic slides with text-over-visual layouts.",
          specialty:
            "Covers diagram-dense decks; emphasizes entity extraction across slide transitions.",
          paperLink: "",
          dataLink: "https://github.com/nttmdlab-nlp/SlideVQA",
          loadData:
            "HF snapshot helper: python - <<'PY'\nfrom huggingface_hub import snapshot_download\nsnapshot_download('NTT-hil-insight/SlideVQA', repo_type='dataset', local_dir='SlideVQA')\nPY",
          dataSize: "",
          queryMod: "T+I",
          targetMod: "T",
          numQuery: 14484,
          numCandidates: "",
          customTags: [],
        },
        {
          id: "seed-4",
          type: "Evaluation Set",
          task: "IconQA",
          modalities: ["Text", "Image"],
          domain: "Daily Icons",
          dataPoints: 31578,
          taskCategory: "Icon Reasoning",
          description:
            "Icon-based question answering dataset centered on math and logic problems drawn as infographics.",
          specialty:
            "Requires reasoning over stylized pictograms rather than natural images; multiple skills per sample.",
          paperLink: "",
          dataLink: "https://iconqa.github.io/",
          loadData:
            "S3 direct: https://iconqa2021.s3.us-west-1.amazonaws.com (download iconqa_data.zip) • or run repo helper: bash tools/download_data_and_models.sh",
          dataSize: "",
          queryMod: "T+I",
          targetMod: "T",
          numQuery: 31578,
          numCandidates: 57672,
          customTags: [],
        },
        {
          id: "seed-5",
          type: "Evaluation Set",
          task: "AI2D-RST",
          modalities: ["Text", "Other"],
          domain: "Science Diagrams",
          dataPoints: 1000,
          taskCategory: "Educational Diagram",
          description:
            "Structural multimodal diagram understanding dataset with rhetorical and perceptual annotations.",
          specialty:
            "Semiotically grounded corpus designed for retrieval-enhanced reasoning over textbook diagrams.",
          paperLink: "",
          dataLink: "https://github.com/thiippal/AI2D-RST",
          loadData:
            "AI2D-RST v1.1 zip: https://korp.csc.fi/download/AI2D-RST/v1.1/ai2d-rst-v1-1.zip • Original AI2D diagrams: https://ai2-website.s3.amazonaws.com/data/ai2d-all.zip",
          dataSize: "",
          queryMod: "T+I",
          targetMod: "T",
          numQuery: "",
          numCandidates: 1000,
          customTags: [],
        },
        {
          id: "seed-6",
          type: "Evaluation Set",
          task: "Dyn-VQA",
          modalities: ["Text", "Image"],
          domain: "Mixed Domain",
          dataPoints: 1452,
          taskCategory: "Multimodal RAG / VQA",
          description:
            "Dynamic multimodal VQA requiring adaptive, multi-hop external knowledge retrieval.",
          specialty:
            "Built for mRAG pipelines; emphasizes planning adaptive retrieval (OmniSearch) with evolving answers.",
          paperLink:
            "Benchmarking Multimodal Retrieval Augmented Generation with Dynamic VQA Dataset and Self-adaptive Planning Agent",
          dataLink: "",
          loadData:
            "HF snapshot helper: python - <<'PY'\nfrom huggingface_hub import snapshot_download\nsnapshot_download('zhzhen23/DynVQA', repo_type='dataset', local_dir='DynVQA')\nPY",
          dataSize: "",
          queryMod:
            "Text + Image (complex open-ended questions needing visual + external knowledge)",
          targetMod: "T",
          numQuery: 1452,
          numCandidates: "",
          customTags: [],
        },
        {
          id: "seed-7",
          type: "Training Set",
          task: "PDF-MVQA",
          modalities: ["Text", "Image"],
          domain:
            "Research journal articles (scientific / technical papers)",
          dataPoints: 262928,
          taskCategory: "Multimodal Document IR / VQA",
          description:
            "Large-scale PDF-based QA dataset requiring retrieval of paragraphs, figures, and tables.",
          specialty:
            "Layout-aware supervision with explicit evidence linking for retrieval-augmented generation.",
          paperLink: "https://arxiv.org/abs/2404.12720",
          dataLink:
            "Structured training PKL: https://drive.google.com/file/d/1AtZaq3M_tCVoTgyp7xxSvXwO0-cs_HFM/view\nQA train CSV: https://drive.google.com/file/d/1-BVyeBf0E_9H9JZVupEgIwoGm_B-8YBR/view\nQA val CSV: https://drive.google.com/file/d/1tluQaTENTwWxy6m2Ut9NAWIW7Yn70Q1_/view\nImages folder: https://drive.google.com/drive/folders/120dvYlID_D8cZ5-lOYHyu1WuHRKEMac6",
          loadData: "Direct Google Drive downloads (see links).",
          dataSize: "",
          queryMod:
            "Text + Image (PDF pages containing dense text + figures/tables)",
          targetMod: "Text (answer generation / evidence retrieval)",
          numQuery: 262928,
          numCandidates: "",
          customTags: [],
        },
        {
          id: "seed-8",
          type: "Training Set",
          task: "SPIQA",
          modalities: ["Image", "Text"],
          domain: "Scientific research papers (computer science)",
          dataPoints: 270000,
          taskCategory: "Scientific Paper Image QA / CoT",
          description:
            "Questions grounded jointly in figures/tables and adjacent text, with CoT evaluation labels.",
          specialty:
            "Targets interleaved reasoning over chart segments and textual context from CS papers.",
          paperLink: "https://arxiv.org/abs/2407.09413",
          dataLink: "",
          loadData:
            "HF snapshot helper: python - <<'PY'\nfrom huggingface_hub import snapshot_download\nsnapshot_download('google/spiqa', repo_type='dataset', local_dir='SPIQA')\nPY",
          dataSize: "",
          queryMod: "Image (figures/tables) + surrounding text",
          targetMod: "Text (free-form answers, CoT evaluations)",
          numQuery: 270000,
          numCandidates: "",
          customTags: [],
        },
        {
          id: "seed-9",
          type: "Evaluation Set",
          task: "RecipeQA",
          modalities: ["Text", "Image"],
          domain: "Cooking / procedural knowledge",
          dataPoints: 36786,
          taskCategory: "Multimodal Procedural Reasoning",
          description:
            "Temporal and cross-modal reasoning benchmark over interleaved recipe instructions and images.",
          specialty:
            "Supports cloze, ordering, and coherence subtasks; requires grounding each step visually.",
          paperLink:
            "RecipeQA: A Challenge Dataset for Multimodal Comprehension of Cooking Recipes",
          dataLink:
            "Train JSON: https://vision.cs.hacettepe.edu.tr/recipeqa/train.json.gz\nVal JSON: https://vision.cs.hacettepe.edu.tr/recipeqa/val.json.gz\nTest JSON: https://vision.cs.hacettepe.edu.tr/recipeqa/test.json.gz\nImages (2.3 GB): https://vision.cs.hacettepe.edu.tr/recipeqa/images.zip",
          loadData: "",
          dataSize: "",
          queryMod:
            "Text + Image (stepwise recipe instructions with illustrative photos)",
          targetMod: "Text / Choice",
          numQuery: 36786,
          numCandidates: "",
          customTags: [],
        },
        {
          id: "seed-10",
          type: "Evaluation Set",
          task: "OK-VQA",
          modalities: ["Text", "Image"],
          domain: "General world knowledge",
          dataPoints: 14055,
          taskCategory: "Knowledge-Based VQA",
          description:
            "VQA benchmark where outside knowledge is required; image alone is insufficient.",
          specialty:
            "Encourages retrieval of real-world facts to answer MSCOCO-based questions.",
          paperLink: "",
          dataLink: "https://okvqa.allenai.org/",
          loadData:
            "Annotations: https://okvqa.allenai.org/static/data/mscoco_train2014_annotations.json.zip\nQuestions: https://okvqa.allenai.org/static/data/OpenEnded_mscoco_train2014_questions.json.zip\nImages (COCO 2014): https://images.cocodataset.org/zips/",
          dataSize: "",
          queryMod: "Text + Image",
          targetMod: "Text (Open-ended)",
          numQuery: 14055,
          numCandidates: "",
          customTags: [],
        },
      ];

      const parseTags = (value = "") =>
        value
          .split(/,|\n/)
          .map((tag) => tag.trim())
          .filter(Boolean);

      const deriveAutoTags = (entry) => {
        const tags = new Set();
        const push = (value) => {
          if (value && String(value).trim()) {
            tags.add(String(value).trim());
          }
        };
        (entry.modalities || []).forEach(push);
        push(entry.domain);
        if (entry.queryMod || entry.targetMod || entry.numQuery || entry.numCandidates) {
          tags.add("RAG");
        }
        return Array.from(tags);
      };

      const combineTags = (entry) => {
        return Array.from(new Set([...deriveAutoTags(entry), ...(entry.customTags || [])]));
      };

      const STORAGE_KEY = "mmDatasetEntries-v3";

      const getSavedEntriesFromStorage = () => {
        try {
          const saved = localStorage.getItem(STORAGE_KEY);
          if (saved) return JSON.parse(saved);
          for (const key of ["mmDatasetEntries-v2", "mmDatasetEntries-v1"]) {
            const legacy = localStorage.getItem(key);
            if (legacy) return JSON.parse(legacy);
          }
        } catch (e) { console.warn("Unable to parse saved entries", e); }
        return null;
      };

      const getSavedEntries = async () => {
        if (firestoreDb) {
          try {
            const ref = firestoreDb.doc(FIRESTORE_DOC);
            const snap = await ref.get();
            if (snap.exists && snap.data().list && Array.isArray(snap.data().list))
              return snap.data().list;
          } catch (e) {
            console.warn("Firestore get failed; falling back to localStorage", e);
          }
        }
        return getSavedEntriesFromStorage();
      };

      let datasetEntries = [];

      const uniqueValues = (values) =>
        [...new Set(values.filter((value) => value && value.trim()))].sort((a, b) =>
          a.localeCompare(b)
        );

      const setSelectOptions = (select, values) => {
        const placeholder = select.dataset.placeholder || "All";
        const key = select.dataset.filterKey;
        const current = filters[key];
        select.innerHTML = "";
        const baseOption = document.createElement("option");
        baseOption.value = "";
        baseOption.textContent = placeholder;
        select.appendChild(baseOption);
        values.forEach((value) => {
          const option = document.createElement("option");
          option.value = value;
          option.textContent = value;
          select.appendChild(option);
        });
        if (current && !values.includes(current)) {
          filters[key] = "";
          select.value = "";
        } else if (current) {
          select.value = current;
        }
      };

      const populateFilterOptions = () => {
        setSelectOptions(filterControls.type, uniqueValues(datasetEntries.map((entry) => entry.type)));
        setSelectOptions(
          filterControls.domain,
          uniqueValues(datasetEntries.map((entry) => entry.domain))
        );
        setSelectOptions(
          filterControls.tag,
          uniqueValues(datasetEntries.flatMap((entry) => combineTags(entry)))
        );
      };

      const persistEntries = async () => {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(datasetEntries));
        if (firestoreDb) {
          try {
            await firestoreDb.doc(FIRESTORE_DOC).set({ list: datasetEntries });
          } catch (e) {
            console.warn("Firestore write failed", e);
          }
        }
        populateFilterOptions();
      };

      const normalizeEntry = (entry) => ({
        ...entry,
        modalities: normalizeModalities(entry.modalities ?? entry.modality),
        customTags: Array.isArray(entry.customTags)
          ? entry.customTags
          : parseTags(entry.customTags || ""),
      });

      (async function init() {
        const loadingMsg = document.getElementById("loading-msg");
        let saved = await getSavedEntries();
        if (saved && saved.length > 0) {
          datasetEntries = saved.map(normalizeEntry);
        } else {
          datasetEntries = seedEntries.map(normalizeEntry);
          await persistEntries();
        }
        if (loadingMsg) loadingMsg.remove();
        populateFilterOptions();
        renderTable();
      })();

      ["type", "domain", "tag"].forEach((key) => {
        filterControls[key].addEventListener("change", (event) => {
          filters[key] = event.target.value;
          renderTable();
        });
      });

      filterControls.search.addEventListener("input", (event) => {
        filters.search = event.target.value.trim().toLowerCase();
        renderTable();
      });

      const formatNumber = (value) => {
        if (value === undefined || value === null || value === "") return "—";
        return Number(value).toLocaleString();
      };

      const textToNodes = (text = "") => {
        const fragment = document.createDocumentFragment();
        if (!text) {
          fragment.appendChild(document.createTextNode("—"));
          return fragment;
        }

        const paragraphs = text.split(/\n+/).filter((line) => line.trim().length);
        paragraphs.forEach((paragraph, index) => {
          if (index > 0) fragment.appendChild(document.createElement("br"));
          fragment.appendChild(linkify(paragraph.trim()));
        });
        return fragment;
      };

      const renderLinkList = (text = "") => {
        const fragment = document.createDocumentFragment();
        const links = text
          .split(/,|\n/)
          .map((item) => item.trim())
          .filter(Boolean);

        if (!links.length) {
          fragment.appendChild(document.createTextNode("—"));
          return fragment;
        }

        const wrap = document.createElement("div");
        wrap.className = "link-stack";

        links.forEach((href, index) => {
          const anchor = document.createElement("a");
          anchor.href = href;
          anchor.target = "_blank";
          anchor.rel = "noopener noreferrer";
          anchor.textContent = links.length > 1 ? `Link ${index + 1}` : "Link";
          wrap.appendChild(anchor);
        });

        fragment.appendChild(wrap);
        return fragment;
      };

      const linkify = (line) => {
        const span = document.createElement("span");
        let cursor = 0;
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        let match;

        while ((match = urlRegex.exec(line)) !== null) {
          if (match.index > cursor) {
            span.appendChild(document.createTextNode(line.slice(cursor, match.index)));
          }

          const anchor = document.createElement("a");
          anchor.href = match[0];
          anchor.textContent = match[0];
          anchor.target = "_blank";
          anchor.rel = "noopener noreferrer";
          span.appendChild(anchor);
          cursor = match.index + match[0].length;
        }

        if (cursor < line.length) {
          span.appendChild(document.createTextNode(line.slice(cursor)));
        }

        return span;
      };

      const getFilteredEntries = () => {
        return datasetEntries.filter((entry) => {
          if (filters.type && entry.type !== filters.type) return false;
          if (filters.domain && entry.domain !== filters.domain) return false;
          const tags = combineTags(entry);
          if (filters.tag) {
            const match = tags.some(
              (tag) => tag.toLowerCase() === filters.tag.toLowerCase()
            );
            if (!match) return false;
          }
          if (filters.search) {
            const haystack = [
              entry.type,
              entry.task,
              formatModalities(entry.modalities),
              entry.domain,
              entry.taskCategory,
              entry.description,
              entry.specialty,
              entry.paperLink,
              entry.dataLink,
              entry.loadData,
              entry.dataSize,
              ...tags,
            ]
              .join(" ")
              .toLowerCase();
            if (!haystack.includes(filters.search)) {
              return false;
            }
          }
          return true;
        });
      };

      const renderTable = () => {
        gridContainer.replaceChildren(
          ...getFilteredEntries().map((entry) => createCard(entry))
        );
      };

      const createCard = (entry) => {
        const card = document.createElement("div");
        card.className = "dataset-card";

        // Header
        const header = document.createElement("div");
        header.className = "card-header";

        const title = document.createElement("h3");
        title.className = "card-title";
        title.textContent = entry.task;
        if (entry.paperLink) {
          const paper = document.createElement("a");
          paper.href = entry.paperLink;
          paper.target = "_blank";
          paper.rel = "noopener noreferrer";
          paper.textContent = "Paper";
          title.appendChild(paper);
        }
        header.appendChild(title);

        const actions = document.createElement("div");
        actions.className = "card-actions";

        const editTagsBtn = document.createElement("button");
        editTagsBtn.type = "button";
        editTagsBtn.className = "secondary";
        editTagsBtn.textContent = "Edit Tags";
        editTagsBtn.addEventListener("click", () => editTags(entry.id));

        const cloneBtn = document.createElement("button");
        cloneBtn.type = "button";
        cloneBtn.className = "secondary";
        cloneBtn.textContent = "Clone";
        cloneBtn.addEventListener("click", () => cloneEntry(entry.id));

        const deleteBtn = document.createElement("button");
        deleteBtn.type = "button";
        deleteBtn.className = "danger";
        deleteBtn.textContent = "Delete";
        deleteBtn.addEventListener("click", () => deleteEntry(entry.id));

        actions.append(editTagsBtn, cloneBtn, deleteBtn);
        header.appendChild(actions);
        card.appendChild(header);

        // Tags
        const tagsRow = document.createElement("div");
        tagsRow.className = "card-tags";

        const addPill = (text, highlight = false) => {
          if (!text || text === "—") return;
          const pill = document.createElement("span");
          pill.className = `tag-pill ${highlight ? "highlight" : ""}`;
          pill.textContent = text;
          tagsRow.appendChild(pill);
        };

        addPill(entry.type, true);
        addPill(entry.domain);
        addPill(formatModalities(entry.modalities));
        addPill(entry.taskCategory);
        if (entry.dataPoints) addPill(`${formatNumber(entry.dataPoints)} samples`);
        if (entry.dataSize) addPill(`${entry.dataSize} GB`);
        (entry.customTags || []).forEach((tag) => addPill(tag));

        card.appendChild(tagsRow);

        // Content
        const contentRow = document.createElement("div");
        contentRow.className = "card-content";

        const mainInfo = document.createElement("div");
        mainInfo.className = "card-description";
        const descP = document.createElement("p");
        descP.textContent = entry.description;
        mainInfo.appendChild(descP);

        if (entry.specialty) {
          const specP = document.createElement("p");
          specP.innerHTML = `<strong>Specialty:</strong> ${entry.specialty}`;
          mainInfo.appendChild(specP);
        }
        contentRow.appendChild(mainInfo);

        const logistics = document.createElement("div");
        logistics.className = "card-logistics";

        if (entry.dataLink) {
          const item = document.createElement("div");
          item.className = "logistics-item";
          const label = document.createElement("span");
          label.className = "logistics-label";
          label.textContent = "Data Links";
          item.appendChild(label);
          item.appendChild(renderLinkList(entry.dataLink));
          logistics.appendChild(item);
        }

        if (entry.loadData) {
          const item = document.createElement("div");
          item.className = "logistics-item";
          const label = document.createElement("span");
          label.className = "logistics-label";
          label.textContent = "Load / Logistics";
          item.appendChild(label);
          item.appendChild(textToNodes(entry.loadData));
          logistics.appendChild(item);
        }
        contentRow.appendChild(logistics);
        card.appendChild(contentRow);

        // Retrieval
        const hasRetrieval =
          entry.queryMod || entry.targetMod || entry.numQuery || entry.numCandidates;
        if (hasRetrieval) {
          const retrievalRow = document.createElement("div");
          retrievalRow.className = "card-retrieval";

          const addRetItem = (label, value) => {
            if (!value) return;
            const item = document.createElement("div");
            item.className = "retrieval-item";
            item.innerHTML = `<span class="retrieval-label">${label}</span><span class="retrieval-value">${value}</span>`;
            retrievalRow.appendChild(item);
          };

          addRetItem("Query Modality", entry.queryMod);
          addRetItem("Target Modality", entry.targetMod);
          addRetItem(
            "Num Queries",
            entry.numQuery ? formatNumber(entry.numQuery) : null
          );
          addRetItem(
            "Num Candidates",
            entry.numCandidates ? formatNumber(entry.numCandidates) : null
          );

          card.appendChild(retrievalRow);
        }

        return card;
      };

      const createCell = (value, className) => {
        const cell = document.createElement("td");
        if (className) cell.classList.add(className);
        cell.textContent = value || "—";
        return cell;
      };

      const cloneEntry = (id) => {
        const entry = datasetEntries.find((item) => item.id === id);
        if (!entry) return;
        
        // Store entry in session storage to be picked up by the add-dataset page
        sessionStorage.setItem("cloneEntry", JSON.stringify(entry));
        window.location.href = "add-dataset/";
      };

      const editTags = (id) => {
        const entry = datasetEntries.find((item) => item.id === id);
        if (!entry) return;

        const autoTags = deriveAutoTags(entry);
        const manualTags = entry.customTags || [];
        const message = [
          "Update manual tags (comma-separated).",
          autoTags.length ? `Auto tags: ${autoTags.join(", ")}` : "No auto tags detected.",
        ].join("\n");
        const next = window.prompt(message, manualTags.join(", "));
        if (next === null) return;

        entry.customTags = parseTags(next);
        persistEntries().then(renderTable);
      };

      const deleteEntry = (id) => {
        const attempt = window.prompt("Enter password to delete this entry:");
        if (attempt !== "notawesome") {
          if (attempt !== null) {
            alert("Incorrect password. Row was not deleted.");
          }
          return;
        }
        datasetEntries = datasetEntries.filter((entry) => entry.id !== id);
        persistEntries().then(renderTable);
      };
    </script>
  </body>
</html>
